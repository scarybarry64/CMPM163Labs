<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Lab 5c: Custom Particle Animation</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script src="../three.js-master/build/three.js"></script>
    <script>
        // setup the scene
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75,
            window.innerWidth / window.innerHeight, 0.1, 1000);
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        camera.position.z = 7;


        // generate particles array; stores position, velocity, and acceleration
        particles = []
        const geo = new THREE.Geometry()
        for (let i = 0; i < 15000; i++) {
            const particle = {
                position: new THREE.Vector3(
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1,
                    Math.random() * 3 - 3),
                velocity: new THREE.Vector3(

                    /*
                        Math.random() * .02 - .01,
                        0.06,
                        Math.random() * .02 - .01),
                    */

                    Math.random() * .02 - .01,
                    Math.random() * .02 - .01,
                    0),



                acceleration: new THREE.Vector3(
                    Math.random() * .002 - .001,
                    Math.random() * .002 - .001,
                    0),
            }
            particles.push(particle);
            geo.vertices.push(particle.position)
        }





        var sprite = new THREE.TextureLoader().load('disc.png');
        var material = new THREE.PointsMaterial({
            size: 5,
            sizeAttenuation: false, map: sprite, alphaTest: 0.5,
            transparent: true
        });
        material.color.setHSL(1.0, 0.3, 0.7);
        var mesh = new THREE.Points(geo, material);
        scene.add(mesh);

        let t = 0;



        // "Bat-math"


        function eq1(x, y) {
            return ((x / 7) * (x / 7) * (Math.sqrt((Math.abs(Math.abs(x) - 3)) / (Math.abs(x) - 3))) + (y / 3) * (y / 3) * (Math.sqrt(Math.abs(y + 3 * (Math.sqrt(33) / 7)) / (y + 3 * (Math.sqrt(33) / 7)))) - 1);
        }

        function eq2(x, y) {
            return (Math.abs(x / 2) - ((3 * Math.sqrt(33) - 7) / 112) * x * x - 3 + Math.sqrt(1 - (Math.abs(Math.abs(x) - 2) - 1) * (Math.abs(Math.abs(x) - 2) - 1)) - y);
        }

        function eq3(x, y) {
            return (9 * Math.sqrt(Math.abs((1 - Math.abs(x)) * (Math.abs(x) - 0.75)) / ((1 - Math.abs(x)) * (Math.abs(x) - 0.75))) - 8 * Math.abs(x) - y);
        }

        function eq4(x, y) {
            return (3 * Math.abs(x) + 0.75 * Math.sqrt(Math.abs((0.75 - Math.abs(x)) * (Math.abs(x) - 0.5)) / ((0.75 - Math.abs(x)) * (Math.abs(x) - 0.5))) - y);
        }

        function eq5(x, y) {
            return (2.25 * Math.sqrt(Math.abs((0.5 - x) * (x + 0.5)) / ((0.5 - x) * (x + 0.5))) - y);
        }

        function eq6(x, y) {
            return ((6 * Math.sqrt(10)) / 7 + (1.5 - 0.5 * Math.abs(x)) * Math.sqrt(Math.abs(Math.abs(x) - 1) / (Math.abs(x) - 1)) - ((6 * Math.sqrt(10)) / 14) * Math.sqrt(4 - (Math.abs(x) - 1) * (Math.abs(x) - 1)) - y);
        }



        // finds vector normal to current vector
        function findNormal(x, y) {
            let z = x;
            x = -y;
            y = -z;
        }


        function animate() {




            // increment velocity and position
            particles.forEach(p => {
                //p.velocity.add(p.acceleration);
                //p.position.add(p.velocity);

                //p.velocity.x *= Math.floor(Math.random()*2) == 1 ? 1 : -1;
                //p.velocity.y *= Math.floor(Math.random() * 2) == 1 ? 1 : -1;

                /*
                if (p.position.x < -40.0) {
                    deltaX = 0.4;
                }
                else if (p.position.x > 40.0) {
                    deltaX = -0.4;
                }
                
                if (p.position.y < -20.0) {
                    deltaY = 0.2;
                }
                else if (p.position.x > 20.0) {
                    deltaY = -0.2;
                }
                */

                /*

                p.position.x = 60*Math.cos(t)
                p.position.y = 30*Math.sin(2*t);
                t += 0.01;


                if (t > 6.28) {
                    t = 0;
                }

                */



                if (eq1(p.position.x, p.position.y) >= 0 || eq2(p.position.x, p.position.y) >= 0 ||
                    eq3(p.position.x, p.position.y) <= 0 || eq4(p.position.x, p.position.y) <= 0 ||
                    eq5(p.position.x, p.position.y) <= 0 || eq6(p.position.x, p.position.y) <= 0 ||
                    Math.abs(p.position.x) > 6 || Math.abs(p.position.y) > 3) {

                    /*
                    let temp = p.velocity.x;
                    p.velocity.x = -1 * p.velocity.y
                    p.velocity.y = -1 * temp;
                    */


                    p.position.x = Math.random() * 6;
                    p.position.y = Math.random() * 1;
                    p.position.z = Math.random() * 3 - 3;

                    if (Math.random() > 0.5) {
                        p.position.x *= -1;
                    }
                    if (Math.random() > 0.5) {
                        p.position.y += -1;
                    }


                }

                /*
                if (eq2(p.position.x, p.position.y) >= 0) {
                    let temp = p.velocity.x;
                    p.velocity.x = -1 * p.velocity.y
                    p.velocity.y = -1 * temp;

                }

                if (eq3(p.position.x, p.position.y) <= 0) {
                    let temp = p.velocity.x;
                    p.velocity.x = -1 * p.velocity.y
                    p.velocity.y = -1 * temp;

                }

                if (eq4(p.position.x, p.position.y) <= 0) {
                    let temp = p.velocity.x;
                    p.velocity.x = -1 * p.velocity.y
                    p.velocity.y = -1 * temp;

                }

                if (eq5(p.position.x, p.position.y) <= 0) {
                    let temp = p.velocity.x;
                    p.velocity.x = -1 * p.velocity.y
                    p.velocity.y = -1 * temp;

                }

                if (eq6(p.position.x, p.position.y) <= 0) {
                    let temp = p.velocity.x;
                    p.velocity.x = -1 * p.velocity.y
                    p.velocity.y = -1 * temp;

                }

                if (Math.abs(p.position.x) > 7 || Math.abs(p.position.y > 5)) {
                    let temp = p.velocity.x;
                    p.velocity.x = -1 * p.velocity.y
                    p.velocity.y = -1 * temp;

                }
                */
                //p.velocity.add(p.acceleration);
                p.position.add(p.velocity);

                if (Math.random() > 0.99999) {
                    material.color.setHSL(Math.random(), Math.random(), Math.random());
                }


                /* 
                 p.velocity.x += deltaX;
                 p.velocity.y += deltaY;
                 p.position.add(p.velocity);
                 */
            });
            mesh.geometry.verticesNeedUpdate = true;






            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>

</html>